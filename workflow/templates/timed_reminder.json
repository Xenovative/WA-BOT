[
    {
        "id": "tr-timed-reminder-flow",
        "type": "tab",
        "label": "Timed Reminder",
        "disabled": false,
        "info": "Manual reminder with configurable message and recipients"
    },
    {
        "id": "reminder-trigger",
        "type": "inject",
        "z": "tr-timed-reminder-flow",
        "name": "Send Reminder Now",
        "props": [{"p": "payload"}, {"p": "topic", "vt": "str"}],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 170,
        "y": 120,
        "wires": [["tr-reminder-config"]]
    },
    {
        "id": "tr-reminder-config",
        "type": "function",
        "z": "tr-timed-reminder-flow",
        "name": "Reminder Config",
        "func": "// Configure your reminder here\nreturn {\n    payload: {\n        // List of recipient chat IDs\n        recipients: [\n            \"85261234567@c.us\",  // Example: Hong Kong number\n            \"6581234567@c.us\"    // Example: Singapore number\n        ],\n        // Your reminder message\n        message: \"⏰ Reminder: This is your scheduled message!\",\n        // Schedule (cron format: minute hour day month dayOfWeek)\n        // This example runs every day at 9:30 AM\n        schedule: \"30 9 * * *\"\n    }\n};",
        "outputs": 1,
        "noerr": 0,
        "x": 380,
        "y": 120,
        "wires": [["tr-process-recipients"]]
    },
    {
        "id": "tr-process-recipients",
        "type": "function",
        "z": "tr-timed-reminder-flow",
        "name": "Process Recipients",
        "func": "// Create a message for each recipient\nconst messages = msg.payload.recipients.map(recipient => ({\n    payload: {\n        chatId: recipient,\n        message: msg.payload.message,\n        messageType: \"text\"\n    }\n}));\n\nreturn [messages];",
        "outputs": 1,
        "noerr": 0,
        "x": 630,
        "y": 120,
        "wires": [["tr-send-message"]]
    },
    {
        "id": "tr-send-message",
        "type": "http request",
        "z": "tr-timed-reminder-flow",
        "name": "Send WhatsApp",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://localhost:3000/api/workflow/send-message",
        "tls": "",
        "persist": false,
        "proxy": "",
        "authType": "",
        "x": 870,
        "y": 120,
        "wires": [["tr-log-result"]]
    },
    {
        "id": "tr-log-result",
        "type": "debug",
        "z": "tr-timed-reminder-flow",
        "name": "Log Result",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "x": 1110,
        "y": 120,
        "wires": []
    },
    {
        "id": "tr-scheduler",
        "type": "inject",
        "z": "tr-timed-reminder-flow",
        "name": "Schedule Check",
        "props": [{"p": "payload"}, {"p": "topic", "vt": "str"}],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "",
        "topic": "schedule_check",
        "x": 170,
        "y": 200,
        "wires": [["tr-check-schedule"]]
    },
    {
        "id": "tr-check-schedule",
        "type": "function",
        "z": "tr-timed-reminder-flow",
        "name": "Check Schedule",
        "func": "// cron is already injected via libs array\nconst config = flow.get('timed-reminder.config') || {};\n\n// Debug: Log that we're checking the schedule\nnode.log('Check Schedule running...');\n\n// Get the reminder config from flow context with namespace\nconst reminderConfig = flow.get('timed-reminder.config') || {};\nconst schedule = reminderConfig.schedule;\n\n// Debug: Log what we found in the context\nnode.log('Current reminderConfig: ' + JSON.stringify(reminderConfig));\nnode.log('Schedule found: ' + schedule);\n\n// Convert cron schedule to natural language\nfunction cronToNaturalLanguage(cronExpression) {\n    if (!cronExpression) return 'No schedule defined';\n    \n    const parts = cronExpression.split(' ');\n    if (parts.length !== 5) return 'Invalid cron format';\n    \n    const [minute, hour, dayOfMonth, month, dayOfWeek] = parts;\n    \n    // Day of week mapping\n    const daysOfWeek = {\n        '0': 'Sunday', '1': 'Monday', '2': 'Tuesday', '3': 'Wednesday',\n        '4': 'Thursday', '5': 'Friday', '6': 'Saturday'\n    };\n    \n    // Month mapping\n    const months = {\n        '1': 'January', '2': 'February', '3': 'March', '4': 'April',\n        '5': 'May', '6': 'June', '7': 'July', '8': 'August',\n        '9': 'September', '10': 'October', '11': 'November', '12': 'December'\n    };\n    \n    let description = '';\n    \n    // Time (hour:minute)\n    if (hour !== '*' && minute !== '*') {\n        const formattedHour = parseInt(hour) > 12 ? \n            (parseInt(hour) - 12) + ' PM' : \n            (parseInt(hour) === 0 ? '12 AM' : parseInt(hour) + ' AM');\n        description += `at ${minute} minutes past ${formattedHour}`;\n    }\n    \n    // Day of week\n    if (dayOfWeek !== '*') {\n        if (description) description += ' ';\n        if (dayOfWeek in daysOfWeek) {\n            description += `every ${daysOfWeek[dayOfWeek]}`;\n        } else {\n            description += `every ${dayOfWeek}`;\n        }\n    }\n    \n    // Day of month\n    if (dayOfMonth !== '*') {\n        if (description) description += ' ';\n        description += `on the ${dayOfMonth}${getDaySuffix(dayOfMonth)} day`;\n    }\n    \n    // Month\n    if (month !== '*') {\n        if (description) description += ' ';\n        if (month in months) {\n            description += `of ${months[month]}`;\n        } else {\n            description += `of month ${month}`;\n        }\n    }\n    \n    return description || 'Every minute';\n}\n\n// Helper function to get day suffix (1st, 2nd, 3rd, etc.)\nfunction getDaySuffix(day) {\n    if (day >= 11 && day <= 13) return 'th';\n    switch (day % 10) {\n        case 1: return 'st';\n        case 2: return 'nd';\n        case 3: return 'rd';\n        default: return 'th';\n    }\n}\n\n// First run - initialize from the reminder-config function\nif (!reminderConfig.schedule) {\n    // Try to get initial config from the reminder-config node output\n    node.log('No schedule in context, trying to initialize from msg.payload');\n    \n    // Get the config from the reminder-config node output\n    // This assumes the reminder-config node has been run at least once\n    const msg = { payload: { schedule: '30 9 * * *' } }; // Default schedule\n    \n    // Store configuration in flow context with namespace\n    flow.set('timed-reminder.config', msg.payload);\n    return null;\n}\n\n// Log the schedule in natural language for existing schedules\nnode.log('Schedule in natural language: ' + cronToNaturalLanguage(schedule));\n\n// Validate the schedule\nif (schedule && cron.validate(schedule)) {\n    // Get the current time and the last run time\n    const now = new Date();\n    const lastRun = new Date(reminderConfig.lastRun || 0);\n    \n    node.log('Current time: ' + now.toISOString());\n    node.log('Last run time: ' + lastRun.toISOString());\n    \n    // Calculate next scheduled time manually\n    // For simplicity, we'll just check if it's time to run based on the current time\n    // This is a simplified approach since node-cron doesn't expose parsing methods\n    \n    // Extract schedule parts\n    const [minute, hour, dayOfMonth, month, dayOfWeek] = schedule.split(' ');\n    \n    const currentDate = new Date();\n    const currentMinute = currentDate.getMinutes();\n    const currentHour = currentDate.getHours();\n    const currentDayOfMonth = currentDate.getDate();\n    const currentMonth = currentDate.getMonth() + 1; // JavaScript months are 0-indexed\n    const currentDayOfWeek = currentDate.getDay(); // 0 = Sunday, 1 = Monday, etc.\n    \n    // For simplicity, we'll just log the current time components\n    node.log(`Current time components: ${currentHour}:${currentMinute} on day ${currentDayOfMonth}, month ${currentMonth}, weekday ${currentDayOfWeek}`);\n    node.log(`Schedule components: minute=${minute}, hour=${hour}, day=${dayOfMonth}, month=${month}, weekday=${dayOfWeek}`);\n    \n    // Check if it's time to trigger the reminder (treat '*' as match-all)\n    const isMinuteMatch = (minute === '*' || currentMinute == minute);\n    const isHourMatch = (hour === '*' || currentHour == hour);\n    const isDayOfMonthMatch = (dayOfMonth === '*' || currentDayOfMonth == dayOfMonth);\n    const isMonthMatch = (month === '*' || currentMonth == month);\n    const isDayOfWeekMatch = (dayOfWeek === '*' || currentDayOfWeek == dayOfWeek);\n    \n    if (isMinuteMatch && isHourMatch && isDayOfMonthMatch && isMonthMatch && isDayOfWeekMatch) {\n        node.log('Time to trigger the reminder!');\n        \n        // Update the last run time\n        flow.set('timed-reminder.config', {\n            ...reminderConfig,\n            lastRun: now.toISOString(),\n            lastChecked: now.toISOString()\n        });\n        \n        // Trigger the reminder\n        return { payload: 'trigger' };\n    } else {\n        node.log('Not time to trigger yet.');\n    }\n} else {\n    node.warn('Invalid schedule format: ' + schedule);\n}\n\n// Store the last check time\nflow.set('timed-reminder.config', {\n    ...reminderConfig,\n    lastCheck: now.toISOString()\n});\n\nnode.log('Check complete, no trigger needed');\nreturn null;",
        "outputs": 1,
        "libs": [{"var":"cron","module":"node-cron"}],
        "x": 380,
        "y": 200,
        "wires": [["tr-reminder-config"]]
    },
    {
        "id": "tr-whatsapp-message-in",
        "type": "mqtt in",
        "z": "tr-timed-reminder-flow",
        "name": "WhatsApp Messages",
        "topic": "whatsapp/messages",
        "qos": "2",
        "datatype": "json",
        "broker": "",
        "nl": false,
        "rap": true,
        "rh": 0,
        "x": 170,
        "y": 280,
        "wires": [
            ["tr-detect-acknowledgement"]
        ]
    },
    {
        "id": "tr-detect-acknowledgement",
        "type": "function",
        "z": "tr-timed-reminder-flow",
        "name": "Detect Acknowledgement",
        "func": "// Check if the message is an acknowledgement response\nconst msg = {...msg};\nconst text = msg.payload.text || '';\nconst lowerText = text.toLowerCase();\n\n// List of acknowledgement keywords in different languages\nconst acknowledgements = [\n    'ok', 'okay', 'got it', 'understood', 'thanks', 'thank you', 'received',\n    '好', '好的', '收到', '明白', '謝謝', '谢谢', '收到了', '知道了'\n];\n\n// Check if the message contains any acknowledgement keyword\nconst isAcknowledgement = acknowledgements.some(keyword => \n    lowerText.includes(keyword.toLowerCase())\n);\n\nif (isAcknowledgement) {\n    // Store the chat ID for the response\n    msg.chatId = msg.payload.chatId;\n    return [msg, null];\n} else {\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 280,
        "wires": [
            ["tr-prepare-assurance"],
            []
        ]
    },
    {
        "id": "tr-prepare-assurance",
        "type": "function",
        "z": "tr-timed-reminder-flow",
        "name": "Prepare Assurance Message",
        "func": "// Prepare an assuring response message\nreturn {\n    payload: {\n        chatId: msg.chatId,\n        message: 'Thank you for confirming. Your acknowledgement has been recorded. If you have any questions, feel free to ask.',\n        messageType: 'text'\n    }\n};\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 280,
        "wires": [
            ["tr-send-assurance"]
        ]
    },
    {
        "id": "tr-send-assurance",
        "type": "http request",
        "z": "tr-timed-reminder-flow",
        "name": "Send Assurance",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://localhost:3000/api/send-message",
        "tls": "",
        "persist": false,
        "proxy": "",
        "authType": "",
        "x": 830,
        "y": 280,
        "wires": [
            ["tr-log-assurance"]
        ]
    },
    {
        "id": "tr-log-assurance",
        "type": "debug",
        "z": "tr-timed-reminder-flow",
        "name": "Log Assurance",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1030,
        "y": 280,
        "wires": []
    }
]